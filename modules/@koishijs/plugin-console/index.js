import{Schema as k}from"https://registry.koishi.chat/modules/koishi/index.js";import{coerce as x,Logger as w,makeArray as _,Random as f,Service as O}from"https://registry.koishi.chat/modules/koishi/index.js";import{Service as S}from"https://registry.koishi.chat/modules/koishi/index.js";var u=Object.defineProperty,g=(e,t,r)=>t in e?u(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,a=(e,t)=>u(e,"name",{value:t,configurable:!0}),p=(e,t,r)=>(g(e,typeof t!="symbol"?t+"":t,r),r),y=class extends S{constructor(e,t,r={}){super(e,`console.${t}`,r.immediate),this.ctx=e,this.key=t,this.options=r,y.define(t)}static define(e){if(this.keys.add(e),Object.prototype.hasOwnProperty.call(d.prototype,e))return;let t=`console.${e}`;Object.defineProperty(d.prototype,e,{get(){return this.caller[t]},set(r){this.caller[t]=r}})}get(e){return null}start(){this.refresh()}async refresh(){this.ctx.console?.broadcast("data",{key:this.key,value:await this.get(!0)},this.options)}patch(e){this.ctx.console?.broadcast("patch",{key:this.key,value:e},this.options)}},c=y;a(c,"DataService");p(c,"keys",new Set);var h=new w("console"),v=class{constructor(e,t){this.ctx=e,this.socket=t,t.onmessage=this.receive.bind(this),this.refresh()}id=f.id();send(e){this.socket.send(JSON.stringify(e))}async receive(e){let{type:t,args:r,id:i}=JSON.parse(e.data.toString()),n=this.ctx.console.listeners[t];if(!n)return h.info("unknown message:",t,...r),this.send({type:"response",body:{id:i,error:"not implemented"}});if(await this.ctx.serial("console/intercept",this,n))return this.send({type:"response",body:{id:i,error:"unauthorized"}});try{let s=await n.callback.call(this,...r);return this.send({type:"response",body:{id:i,value:s}})}catch(s){h.debug(s);let m=x(s);return this.send({type:"response",body:{id:i,error:m}})}}refresh(){c.keys.forEach(async e=>{let t=this.ctx[`console.${e}`];if(t){if(await this.ctx.serial("console/intercept",this,t.options))return this.send({type:"data",body:{key:e,value:null}});try{let r=await t.get();if(!r)return;this.send({type:"data",body:{key:e,value:r}})}catch(r){this.ctx.logger("console").warn(r)}}})}};a(v,"Client");var b=class extends c{constructor(e){super(e,"entry",{immediate:!0})}async get(){return this.ctx.console.get()}};a(b,"EntryProvider");var o=class extends O{constructor(e){super(e,"console",!0),this.ctx=e,e.plugin(b)}entries=Object.create(null);listeners=Object.create(null);clients=Object.create(null);accept(e){let t=new v(this.ctx,e);e.onclose=()=>{delete this.clients[t.id],this.ctx.emit("console/connection",t)},this.clients[t.id]=t,this.ctx.emit("console/connection",t)}async get(){return Object.values(this.entries).flat()}addEntry(e){let t=this.caller,r="extension-"+f.id();this.entries[r]=_(this.resolveEntry(e)),this.entry.refresh(),t?.on("dispose",()=>{delete this.entries[r],this.entry?.refresh()})}addListener(e,t,r){this.listeners[e]={callback:t,...r}}broadcast(e,t,r={}){if(!Object.values(this.clients).length)return;let n=JSON.stringify({type:e,body:t});Promise.all(Object.values(this.clients).map(async s=>{await this.ctx.serial("console/intercept",s,r)||s.socket.send(n)}))}};a(o,"Console");p(o,"filter",!1);var d=o;var P=Object.defineProperty,j=(e,t)=>P(e,"name",{value:t,configurable:!0}),l=class extends o{start(){this.accept(this.ctx.loader[Symbol.for("koishi.socket")])}resolveEntry(e){return typeof e=="string"||Array.isArray(e)?e:e.prod}};j(l,"BrowserConsole");(e=>{e.Config=k.object({})})(l||(l={}));var z=l;export{v as Client,o as Console,c as DataService,b as EntryProvider,z as default};
